\section{Проектирование и реализация} % (fold)
\label{sec:arch_and_realization}


Разработанное программное обеспечение представляет из себя веб-приложение, написанное на фреймворке \ror.
Приложение предназначено для получения новинок музыкальной индустрии или, другими словами, музыкальных релизов выбранных пользователем музыкантов.

Существует множество подходов для построения архитектуры веб-приложений. Я выбрал в своей реализации трёхуровневую архитектуру.

\subsection{Трёхуровневая архитекутра приложения}
\label{sub:arch_and_mod:mvc}

Архитектура приложения - это определённый подход в определении взаимоотношений компонентов приложения. Обычно архитектура приложений соответствует задачам разработки. В данной дипломной работе выбрана трёхуровневая архитектура. Эти уровни называются: уровень модели, уровень контроллера и уровень представления. Иначе говоря, MVC - Model, View, Controller.

Данная архитектура используется во множестве веб-фреймворков. Она удобна тем, что позволяет разделить зоны ответственности между компонентами, облегчить тестирование, придать гибкость разработке. Фреймворк \ror{} и \ajs{} также в своей основе используют данную архитектуру.

\subsubsection{Уровень модели}
\label{sub:arch_and_mod:mvc:model}
~\\

Уровень модели - один из трёх уровней в MVC-архитектуре. Его обязанности можно разделить на две категории:

\begin{itemize}
  \item бизнес-логика приложения;
  \item управление связью в базой данных;
\end{itemize}

Бизнес-логика включает в себя определённые правила, отношения и принципы, которые должны существовать в приложении. Эти правила могут быть выражены как в коде самого приложения, так и базе данных. Однако в данной дипломной работе бизнес-логика содержится именно в коде приложения, а именно в ruby-классах, наследующихся от класса ActiveRecord::Base, который является стандартом де-факто для моделей, использующихся во фреймворке \ror{}.

В данной дипломной работе присутствует класс ReleaseIdentity, который используется для хранения и обработки объектов музыкальных публикаций. Пример реализации класса ReleaseIdentity представлен на листинге~\ref{lst:arch_and_mod:mvc:model:release_identity_class_definition}:
\begin{lstlisting}[style=fsharpstyle,caption={Базовая реализация класса ReleaseIdentity}, label=lst:arch_and_mod:mvc:model:release_identity_class_definition]
class ReleaseIdentity < ActiveRecord::Base
end
\end{lstlisting}

Классы-наследники класса ActiveRecord::Base обладают богатым функционалом. Они содержат в себе возможности валидирования, организации связей между объектами, возможностями создания транзакций, сложных запросов в БД и многими другими. Подробнее об этом будет написано несколько позже, когда будет рассматриваться взаимодействие с БД.

Ярким примером бизнес-логики может служить проверка корректности конструируемых объектов. Например, название артиста не должно быть пустым и содержать только текстовые данные. Или же год начала карьеры артиста не может быть отрицательными или больше нынешнего года по значению. Всё это реализуется в \ror{} с помощью механизма валидации.

В данной дипломной работе присутствует класс RymArtistsInfo, который используется для хранения результатов работы с сервисом Rate Your Music\footnote{\url{https://rateyourmusic.com/}}. В этом классе присутствуют следующие поля:

\begin{itemize}
  \item id - уникальный идентификатор записи в таблице;
  \item formed year - год формирования музыкальной группы(исполнителя);
  \item disbanded yead - год окончания деятельности музыкальной группы(исполнителя);
  \item genres - жанры, которые присущи музыкальной группе(исполнителю);
  \item created at - дата создания записи в БД приложения;
  \item updated at - дата обновления записи в БД приложения;
\end{itemize}

В данном случае годы формирования и окончания деятельности музыкальной группы исполнителя должны придерживаться правил, описанных выше. Также строка, содержащая жанры, не может иметь длину, менее 2 символов. Для обеспечения этой части бизнес-логики я воспользовался инструментарием фреймворка \ror{}. Используя метод validates, можно добиться проверки определённых правил перед сохранением записи, чтобы хранить в базе только корректные записи. Также существует метод validate, в который передаётся название метода, в котором можно описать более сложную логику. Таким образом можно проверить то, что год окончания деятельности музыкальной группы больше или равен году начала карьеры. Пример использования продемонтрирован на листинге ~\ref{lst:arch_and_mod:mvc:model:rym_artists_info_validations}:

\begin{lstlisting}[style=fsharpstyle,caption={Реализация валидации в классе RymArtistsInfo}, label=lst:arch_and_mod:mvc:model:rym_artists_info_validations]
class RymArtistsInfo < ActiveRecord::Base
  validates :formed_year
  validates :disbanded_year, numericality: {only_integer: true, greated_than: 0, less_than: DateTime.now.year}
  validates :genres, length: {minimum: 2}
  validate disbanded_more_or_eql_formed

  private

  def disbanded_more_or_equal_formed
    disbanded_year >= formed_year
  end
end
\end{lstlisting}

Фреймворк \ror{} предлагает ещё один полезный инструмент, который называется "функция обратного вызова". Такие функции существуют и на уровне базы данных, но в этом и состоит преимущество веб-фреймворка - позволять более компактно и удобно писать необходимый функционал. Функции обратного вызова работают таким образом, что в определённые моменты жизненного цикла объектов, такие, как перед сохранением, удалением или валидированием объекта, вызываются методы, в который можный поместить необходимый для этого момента код. Это ещё одно преимущество слоя модели, потому как позволяет избегать длинных цепочек вызовов методов, а воспользоваться удобным интерфейсом для обработки моментов жизненного цикла. В \ror{} такие моменты обрабатываются путём добавления методов:
\begin{itemize}
  \item before\_save;
  \item before\_create;
  \item before\_validate;
  \item around\_save;
  \item after\_save;
  \item after\_update;
  \item и др.;
\end{itemize}

-- КОД КОЛБЭКА --

%% поместить какой-нибудь код колбэка

Стоит обратить внимание на тот факт, что с ростом приложений модели включают в себя всё больше логики и становятся очень большими. Минус этого состоит в том, что происходит нарушение одного из принципов объектно-ориентированного программирования. Это принцип единственной ответственности класса. Он нарушается в тот момент, когда класс выполняет много различных функций: используется для подключения к БД, содержания бизнес-логики, создания других объектов и т.д. Однако существует способ улучшения данной архитектуры путём введения в слой модели дополнительного компонента - сервиса. Сервисы - это такие классы или модули, который содержат в себе код, который можно извлечь из модели, чтобы её не перегружать. Например, сервисы могут содержать в себе код обращения в стороннему приложению, либо расчёт цен и многое другое. Более того, код сервисов может использоваться в различных местах, тем самым обеспечивая модульность. Это помогает проще тестировать. Кроме этого, сервисы реализуют принцип инкапсуляции, то есть принцип сокрытия реализации. Имеется в виду, что коду, использующему сервис, необязательно знать, как именно реализован тот или иной метод. Если сервис отвечает за работу с поиском и передачей музыкальных публикаций, то коду, работающему с этим сервисом не важно, берёт сервис публикации с помощью API, делает запрос в БД или же эти публикации просто лежат в массиве в памяти приложения.

-- НАПИСАТЬ ПРИМЕР КАКОГО\-НИБУДЬ СЕРВИСА --

Также слой модели ответственнен за работу с базой данных. Большим преимуществом данного слоя вообще и конкретно в реализации ActiveRecord является то, что данная ORM имеет один интерфейс для работы с различными базами данных, будь то PostgreSQL, MySQL, SQLite или другие. Используя классы, унаследованные от ActiveRecord::Base, можно обращаться к базе данных для того, чтобы получить список артистов, релизов или пользователей с помощью языка Ruby. Например, если необходимо сделать выборку артистов, год начала деятельности которых больше какого-то определённого, при этом не выбирая все поля, а только год прекращения деятельности и дату создания записи в БД, используется код, указанный в листинге ~\ref{lst:arch_and_mod:mvc:model:select_artist_where_year}:

\begin{lstlisting}[style=fsharpstyle,caption={Пример получения артистов по определённым параметрам}, label=lst:arch_and_mod:mvc:model:select_artist_where_year]
  artists = RymArtistsInfo.select(:disbanded_year, :created_at).where('formed_year > ?', Date.new(2000, 4, 3))
\end{lstlisting}

Таким образом, классы, унаследованные от ActiveRecord::Base предоставляют удобный интерфейс, который помогает не писать чистый SQL-код. Возможности ActiveRecord::Base не ограничиваются простыми запросами. Существуют методы, которые позволяют делать сложные JOIN-запросы, избегать проблемы "N+1" и т.д.
